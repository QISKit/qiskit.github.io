<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <link href="https://fonts.googleapis.com/css?family=IBM+Plex+Mono|IBM+Plex+Sans|IBM+Plex+Sans+Condensed|IBM+Plex+Serif" rel="stylesheet">
    <script>
          /* Define digital data object based on _appInfo object */
          window.digitalData = {
            page: {
              pageInfo: {
                productTitle: 'IBM Q Experience',
                analytics: {
                  category: 'Qiskit.org',
                },
              },
            },
          };
          window._analytics = {
            segment_key: 'ffdYLviQze3kzomaINXNk6NwpY9LlXcw',
            coremetrics: false,
            optimizely: false,
            googleAddServices: false,
            fullStory: false,
            autoPageEventSpa: true,
            autoFormEvents: false,
            autoPageView: true,
            preventPageEvent: true,
          };
       </script>
        <script src="https://cloud.ibm.com/analytics/build/bluemix-analytics.min.js"></script>
    
    <title>qiskit.circuit.quantumcircuit &#8212; Qiskit 0.13.0 documentation</title>

    <link rel="stylesheet" href="../../../_static/material-icons.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx_tabs/semantic-ui-2.4.1/segment.min.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx_tabs/semantic-ui-2.4.1/menu.min.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx_tabs/semantic-ui-2.4.1/tab.min.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx_tabs/tabs.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/material-design-lite-1.3.0/material.blue-indigo.min.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sphinx_materialdesign_theme.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <script type="text/javascript" src="../../../_static/sphinx_tabs/semantic-ui-2.4.1/tab.min.js"></script>
    <script type="text/javascript" src="../../../_static/sphinx_tabs/tabs.js"></script>
    <script type="text/javascript" src="../../../_static/js/themeExt.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script type="text/javascript" src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head>
<body>
  <header>
    <div class="toolbar limited-width">
      <a href="/" class="home">Qiskit</a>
      <nav class="first">
        <a href="/terra">Terra</a>
        <a href="/aer">Aer</a>
        <a href="/aqua">Aqua</a>
        <a href="/ignis">Ignis</a>
        <a href="/ibmqaccount">IBM Q Account</a>
      </nav>
      <nav class="second">
        <a class="external" id="educationLink" href="https://community.qiskit.org/education">Community</a>
        <a class="external" id="tutorialsLink" href="https://quantum-computing.ibm.com/jupyter/tutorial/1_start_here.ipynb" target="_blank">Tutorials</a>
        <a class="external" href="/documentation" selected>API Documentation</a>
      </nav>
    </div>
  </header>
    <div class="mdl-layout mdl-js-layout  mdl-layout--fixed-drawer"><header class="mdl-layout__drawer">
    
          <!-- Title -->
      <span class="mdl-layout-title">
          <a class="title" href="../../../index.html">
              <span class="title-text">
                  Qiskit
              </span>
          </a>
      </span>
    

<div class="languages" >
    <span>Select a language: </span>
	<span>
	    <select id="language" name="languages">
	        <option value="en">English</option>
	        <option value="ja">Japanese</option>
        </select>
    </span>
</div>
<div id="searchbox" role="search">
    <div class="searchformwrapper">
    <form class="search-form" action="../../../search.html" method="get">
      <input type="text" name="q" class="search-input" placeholder="Search docs..."/>
        <button type="submit" class="search-button">
            <svg height="20" width="20" fill="#6F6F6F" viewBox="0 0 32 32" class="search-button-icon">
                <title>search</title>
                <g>
                    <path d="M30 28.586l-7.552-7.552a11.018 11.018 0 1 0-1.414 1.414L28.586 30zM5 14a9 9 0 1 1 9 9 9.01 9.01 0 0 1-9-9z"></path>
                </g>
            </svg>
        </button>
    </form>
    </div>
</div>
<div class="globaltoc">
  <span class="mdl-layout-title toc">Table Of Contents</span>
  
  
  
  <!-- Local TOC -->
  <nav class="mdl-navigation"></nav>
  
  </div>

</header>
        <main class="mdl-layout__content" tabIndex="0">
<header class="mdl-layout__drawer">
    
          <!-- Title -->
      <span class="mdl-layout-title">
          <a class="title" href="../../../index.html">
              <span class="title-text">
                  Qiskit
              </span>
          </a>
      </span>
    

<div class="languages" >
    <span>Select a language: </span>
	<span>
	    <select id="language" name="languages">
	        <option value="en">English</option>
	        <option value="ja">Japanese</option>
        </select>
    </span>
</div>
<div id="searchbox" role="search">
    <div class="searchformwrapper">
    <form class="search-form" action="../../../search.html" method="get">
      <input type="text" name="q" class="search-input" placeholder="Search docs..."/>
        <button type="submit" class="search-button">
            <svg height="20" width="20" fill="#6F6F6F" viewBox="0 0 32 32" class="search-button-icon">
                <title>search</title>
                <g>
                    <path d="M30 28.586l-7.552-7.552a11.018 11.018 0 1 0-1.414 1.414L28.586 30zM5 14a9 9 0 1 1 9 9 9.01 9.01 0 0 1-9-9z"></path>
                </g>
            </svg>
        </button>
    </form>
    </div>
</div>
<div class="globaltoc">
  <span class="mdl-layout-title toc">Table Of Contents</span>
  
  
  
  <!-- Local TOC -->
  <nav class="mdl-navigation"></nav>
  
  </div>

</header>

    <div class="document">
        <div class="page-content">
        
  <h1>Source code for qiskit.circuit.quantumcircuit</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="c1"># This code is part of Qiskit.</span>
<span class="c1">#</span>
<span class="c1"># (C) Copyright IBM 2017.</span>
<span class="c1">#</span>
<span class="c1"># This code is licensed under the Apache License, Version 2.0. You may</span>
<span class="c1"># obtain a copy of this license in the LICENSE.txt file in the root directory</span>
<span class="c1"># of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.</span>
<span class="c1">#</span>
<span class="c1"># Any modifications or derivative works of this code must retain this</span>
<span class="c1"># copyright notice, and modified files need to carry a notice indicating</span>
<span class="c1"># that they have been altered from the originals.</span>

<span class="sd">&quot;&quot;&quot;Quantum circuit object.&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">deepcopy</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="k">as</span> <span class="nn">mp</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="k">import</span> <span class="n">warn</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">qiskit.circuit.instruction</span> <span class="k">import</span> <span class="n">Instruction</span>
<span class="kn">from</span> <span class="nn">qiskit.qasm.qasm</span> <span class="k">import</span> <span class="n">Qasm</span>
<span class="kn">from</span> <span class="nn">qiskit.exceptions</span> <span class="k">import</span> <span class="n">QiskitError</span>
<span class="kn">from</span> <span class="nn">.parameterexpression</span> <span class="k">import</span> <span class="n">ParameterExpression</span>
<span class="kn">from</span> <span class="nn">.quantumregister</span> <span class="k">import</span> <span class="n">QuantumRegister</span><span class="p">,</span> <span class="n">Qubit</span>
<span class="kn">from</span> <span class="nn">.classicalregister</span> <span class="k">import</span> <span class="n">ClassicalRegister</span><span class="p">,</span> <span class="n">Clbit</span>
<span class="kn">from</span> <span class="nn">.parametertable</span> <span class="k">import</span> <span class="n">ParameterTable</span>
<span class="kn">from</span> <span class="nn">.parametervector</span> <span class="k">import</span> <span class="n">ParameterVector</span>
<span class="kn">from</span> <span class="nn">.instructionset</span> <span class="k">import</span> <span class="n">InstructionSet</span>
<span class="kn">from</span> <span class="nn">.register</span> <span class="k">import</span> <span class="n">Register</span>
<span class="kn">from</span> <span class="nn">.bit</span> <span class="k">import</span> <span class="n">Bit</span>
<span class="kn">from</span> <span class="nn">.quantumcircuitdata</span> <span class="k">import</span> <span class="n">QuantumCircuitData</span>


<span class="k">def</span> <span class="nf">_is_bit</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Determine if obj is a bit&quot;&quot;&quot;</span>
    <span class="c1"># If there is a bit type this could be replaced by isinstance.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Register</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">obj</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Referring to a bit as a tuple is being deprecated. &#39;</span>
                 <span class="s1">&#39;Instead go of (qr, 0), use qr[0].&#39;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span>


<div class="viewcode-block" id="QuantumCircuit"><a class="viewcode-back" href="../../../api/qiskit.circuit.QuantumCircuit.html#qiskit.circuit.QuantumCircuit">[docs]</a><span class="k">class</span> <span class="nc">QuantumCircuit</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Quantum circuit.&quot;&quot;&quot;</span>
    <span class="n">instances</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">prefix</span> <span class="o">=</span> <span class="s1">&#39;circuit&#39;</span>

    <span class="c1"># Class variable OPENQASM header</span>
    <span class="n">header</span> <span class="o">=</span> <span class="s2">&quot;OPENQASM 2.0;&quot;</span>
    <span class="n">extension_lib</span> <span class="o">=</span> <span class="s2">&quot;include </span><span class="se">\&quot;</span><span class="s2">qelib1.inc</span><span class="se">\&quot;</span><span class="s2">;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">regs</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a new circuit.</span>

<span class="sd">        A circuit is a list of instructions bound to some registers.</span>

<span class="sd">        Args:</span>
<span class="sd">            regs: list(:class:`Register`) or list(``int``) The registers to be</span>
<span class="sd">                included in the circuit.</span>

<span class="sd">                 * If a list of :class:`Register` objects, represents the :class:`QuantumRegister`</span>
<span class="sd">                   and/or :class:`ClassicalRegister` objects to include in the circuit.</span>

<span class="sd">                   For example:</span>

<span class="sd">                    * ``QuantumCircuit(QuantumRegister(4))``</span>
<span class="sd">                    * ``QuantumCircuit(QuantumRegister(4), ClassicalRegister(3))``</span>
<span class="sd">                    * ``QuantumCircuit(QuantumRegister(4, &#39;qr0&#39;), QuantumRegister(2, &#39;qr1&#39;))``</span>

<span class="sd">                 * If a list of ``int``, the amount of qubits and/or classical</span>
<span class="sd">                   bits to include in the circuit. It can either be a single</span>
<span class="sd">                   int for just the number of quantum bits, or 2 ints for the number of</span>
<span class="sd">                   quantum bits and classical bits respectively.</span>

<span class="sd">                   For example:</span>

<span class="sd">                    * ``QuantumCircuit(4) # A QuantumCircuit with 4 qubits``</span>
<span class="sd">                    * ``QuantumCircuit(4, 3) # A QuantumCircuit with 4 qubits and 3 classical bits``</span>

<span class="sd">            name (str): the name of the quantum circuit. If not set, an</span>
<span class="sd">                automatically generated string will be assigned.</span>

<span class="sd">        Raises:</span>
<span class="sd">            QiskitError: if the circuit name, if given, is not valid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls_prefix</span><span class="p">()</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cls_instances</span><span class="p">())</span>
            <span class="c1"># pylint: disable=not-callable</span>
            <span class="c1"># (known pylint bug: https://github.com/PyCQA/pylint/issues/1699)</span>
            <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">!=</span> <span class="s2">&quot;win32&quot;</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">current_process</span><span class="p">(),</span> <span class="n">mp</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">ForkProcess</span><span class="p">):</span>
                <span class="n">name</span> <span class="o">+=</span> <span class="s1">&#39;-</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">current_process</span><span class="p">()</span><span class="o">.</span><span class="n">pid</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_increment_instances</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s2">&quot;The circuit name should be a string &quot;</span>
                              <span class="s2">&quot;(or None to auto-generate a name).&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

        <span class="c1"># Data contains a list of instructions and their contexts,</span>
        <span class="c1"># in the order they were applied.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># This is a map of registers bound to this circuit, by name.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qregs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cregs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_register</span><span class="p">(</span><span class="o">*</span><span class="n">regs</span><span class="p">)</span>

        <span class="c1"># Parameter table tracks instructions with variable parameters.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_table</span> <span class="o">=</span> <span class="n">ParameterTable</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_layout</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the circuit data (instructions and context).</span>

<span class="sd">        Returns:</span>
<span class="sd">            QuantumCircuitData: a list-like object containing the tuples for the circuit&#39;s data.</span>

<span class="sd">            Each tuple is in the format ``(instruction, qargs, cargs)``.</span>
<span class="sd">            Where instruction is an Instruction (or subclass) object,</span>
<span class="sd">            qargs is a list of Qubit objects, and cargs is a list of Clbit</span>
<span class="sd">            objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">QuantumCircuitData</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@data</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_input</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the circuit data from a list of instructions and context.</span>

<span class="sd">        Args:</span>
<span class="sd">            data_input (list): A list of instructions with context</span>
<span class="sd">                in the format (instruction, qargs, cargs). Where Instruction</span>
<span class="sd">                is an Instruction (or subclass) object, qargs is a list of</span>
<span class="sd">                Qubit objects, and cargs is a list of Clbit objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If data_input is QuantumCircuitData(self), clearing self._data</span>
        <span class="c1"># below will also empty data_input, so make a shallow copy first.</span>
        <span class="n">data_input</span> <span class="o">=</span> <span class="n">data_input</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">inst</span><span class="p">,</span> <span class="n">qargs</span><span class="p">,</span> <span class="n">cargs</span> <span class="ow">in</span> <span class="n">data_input</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">qargs</span><span class="p">,</span> <span class="n">cargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="s1">&#39;text&#39;</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># TODO: remove the DAG from this function</span>
        <span class="kn">from</span> <span class="nn">qiskit.converters</span> <span class="k">import</span> <span class="n">circuit_to_dag</span>
        <span class="k">return</span> <span class="n">circuit_to_dag</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="n">circuit_to_dag</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_increment_instances</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">instances</span> <span class="o">+=</span> <span class="mi">1</span>

<div class="viewcode-block" id="QuantumCircuit.cls_instances"><a class="viewcode-back" href="../../../api/qiskit.circuit.QuantumCircuit.html#qiskit.circuit.QuantumCircuit.cls_instances">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">cls_instances</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the current number of instances of this class,</span>
<span class="sd">        useful for auto naming.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">instances</span></div>

<div class="viewcode-block" id="QuantumCircuit.cls_prefix"><a class="viewcode-back" href="../../../api/qiskit.circuit.QuantumCircuit.html#qiskit.circuit.QuantumCircuit.cls_prefix">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">cls_prefix</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the prefix to use for auto naming.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">prefix</span></div>

<div class="viewcode-block" id="QuantumCircuit.has_register"><a class="viewcode-back" href="../../../api/qiskit.circuit.QuantumCircuit.html#qiskit.circuit.QuantumCircuit.has_register">[docs]</a>    <span class="k">def</span> <span class="nf">has_register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">register</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Test if this circuit has the register r.</span>

<span class="sd">        Args:</span>
<span class="sd">            register (Register): a quantum or classical register.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if the register is contained in this circuit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">has_reg</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">register</span><span class="p">,</span> <span class="n">QuantumRegister</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">register</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qregs</span><span class="p">):</span>
            <span class="n">has_reg</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">register</span><span class="p">,</span> <span class="n">ClassicalRegister</span><span class="p">)</span> <span class="ow">and</span>
              <span class="n">register</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cregs</span><span class="p">):</span>
            <span class="n">has_reg</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">has_reg</span></div>

<div class="viewcode-block" id="QuantumCircuit.mirror"><a class="viewcode-back" href="../../../api/qiskit.circuit.QuantumCircuit.html#qiskit.circuit.QuantumCircuit.mirror">[docs]</a>    <span class="k">def</span> <span class="nf">mirror</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mirror the circuit by reversing the instructions.</span>

<span class="sd">        This is done by recursively mirroring all instructions.</span>
<span class="sd">        It does not invert any gate.</span>

<span class="sd">        Returns:</span>
<span class="sd">            QuantumCircuit: the mirrored circuit</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reverse_circ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_mirror&#39;</span><span class="p">)</span>
        <span class="n">reverse_circ</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">inst</span><span class="p">,</span> <span class="n">qargs</span><span class="p">,</span> <span class="n">cargs</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">):</span>
            <span class="n">reverse_circ</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inst</span><span class="o">.</span><span class="n">mirror</span><span class="p">(),</span> <span class="n">qargs</span><span class="p">,</span> <span class="n">cargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">reverse_circ</span></div>

<div class="viewcode-block" id="QuantumCircuit.inverse"><a class="viewcode-back" href="../../../api/qiskit.circuit.QuantumCircuit.html#qiskit.circuit.QuantumCircuit.inverse">[docs]</a>    <span class="k">def</span> <span class="nf">inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Invert this circuit.</span>

<span class="sd">        This is done by recursively inverting all gates.</span>

<span class="sd">        Returns:</span>
<span class="sd">            QuantumCircuit: the inverted circuit</span>

<span class="sd">        Raises:</span>
<span class="sd">            QiskitError: if the circuit cannot be inverted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">inverse_circ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_dg&#39;</span><span class="p">)</span>
        <span class="n">inverse_circ</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">inst</span><span class="p">,</span> <span class="n">qargs</span><span class="p">,</span> <span class="n">cargs</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">):</span>
            <span class="n">inverse_circ</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">inst</span><span class="o">.</span><span class="n">inverse</span><span class="p">(),</span> <span class="n">qargs</span><span class="p">,</span> <span class="n">cargs</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">inverse_circ</span></div>

<div class="viewcode-block" id="QuantumCircuit.combine"><a class="viewcode-back" href="../../../api/qiskit.circuit.QuantumCircuit.html#qiskit.circuit.QuantumCircuit.combine">[docs]</a>    <span class="k">def</span> <span class="nf">combine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Append rhs to self if self contains compatible registers.</span>

<span class="sd">        Two circuits are compatible if they contain the same registers</span>
<span class="sd">        or if they contain different registers with unique names. The</span>
<span class="sd">        returned circuit will contain all unique registers between both</span>
<span class="sd">        circuits.</span>

<span class="sd">        Return self + rhs as a new object.</span>

<span class="sd">        Args:</span>
<span class="sd">            rhs (QuantumCircuit): The quantum circuit to append to the right hand side.</span>

<span class="sd">        Returns:</span>
<span class="sd">            QuantumCircuit: Returns a new QuantumCircuit object</span>

<span class="sd">        Raises:</span>
<span class="sd">            QiskitError: if the rhs circuit is not compatible</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check registers in LHS are compatible with RHS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_compatible_regs</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>

        <span class="c1"># Make new circuit with combined registers</span>
        <span class="n">combined_qregs</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qregs</span><span class="p">)</span>
        <span class="n">combined_cregs</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cregs</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">rhs</span><span class="o">.</span><span class="n">qregs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">element</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qregs</span><span class="p">:</span>
                <span class="n">combined_qregs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">rhs</span><span class="o">.</span><span class="n">cregs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">element</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cregs</span><span class="p">:</span>
                <span class="n">combined_cregs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
        <span class="n">circuit</span> <span class="o">=</span> <span class="n">QuantumCircuit</span><span class="p">(</span><span class="o">*</span><span class="n">combined_qregs</span><span class="p">,</span> <span class="o">*</span><span class="n">combined_cregs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">instruction_context</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">rhs</span><span class="o">.</span><span class="n">data</span><span class="p">):</span>
            <span class="n">circuit</span><span class="o">.</span><span class="n">_append</span><span class="p">(</span><span class="o">*</span><span class="n">instruction_context</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">circuit</span></div>

<div class="viewcode-block" id="QuantumCircuit.extend"><a class="viewcode-back" href="../../../api/qiskit.circuit.QuantumCircuit.html#qiskit.circuit.QuantumCircuit.extend">[docs]</a>    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Append QuantumCircuit to the right hand side if it contains compatible registers.</span>

<span class="sd">        Two circuits are compatible if they contain the same registers</span>
<span class="sd">        or if they contain different registers with unique names. The</span>
<span class="sd">        returned circuit will contain all unique registers between both</span>
<span class="sd">        circuits.</span>

<span class="sd">        Modify and return self.</span>

<span class="sd">        Args:</span>
<span class="sd">            rhs (QuantumCircuit): The quantum circuit to append to the right hand side.</span>

<span class="sd">        Returns:</span>
<span class="sd">            QuantumCircuit: Returns this QuantumCircuit object (which has been modified)</span>

<span class="sd">        Raises:</span>
<span class="sd">            QiskitError: if the rhs circuit is not compatible</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check registers in LHS are compatible with RHS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_compatible_regs</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>

        <span class="c1"># Add new registers</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">rhs</span><span class="o">.</span><span class="n">qregs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">element</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qregs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qregs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">rhs</span><span class="o">.</span><span class="n">cregs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">element</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cregs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cregs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>

        <span class="c1"># Add new gates</span>
        <span class="k">for</span> <span class="n">instruction_context</span> <span class="ow">in</span> <span class="n">rhs</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_append</span><span class="p">(</span><span class="o">*</span><span class="n">instruction_context</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">qubits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of quantum bits in the order that the registers had been added.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">qbit</span> <span class="k">for</span> <span class="n">qreg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qregs</span> <span class="k">for</span> <span class="n">qbit</span> <span class="ow">in</span> <span class="n">qreg</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">clbits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of classical bits in the order that the registers had been added.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">cbit</span> <span class="k">for</span> <span class="n">creg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cregs</span> <span class="k">for</span> <span class="n">cbit</span> <span class="ow">in</span> <span class="n">creg</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Overload + to implement self.combine.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Overload += to implement self.extend.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return number of operations in circuit.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return indexed operation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">item</span><span class="p">]</span>

<div class="viewcode-block" id="QuantumCircuit.cast"><a class="viewcode-back" href="../../../api/qiskit.circuit.QuantumCircuit.html#qiskit.circuit.QuantumCircuit.cast">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">cast</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">_type</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Best effort to cast value to type. Otherwise, returns the value.&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">value</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_bit_argument_conversion</span><span class="p">(</span><span class="n">bit_representation</span><span class="p">,</span> <span class="n">in_array</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bit_representation</span><span class="p">,</span> <span class="n">Bit</span><span class="p">):</span>
                <span class="c1"># circuit.h(qr[0]) -&gt; circuit.h([qr[0]])</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span><span class="n">bit_representation</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bit_representation</span><span class="p">,</span> <span class="n">Register</span><span class="p">):</span>
                <span class="c1"># circuit.h(qr) -&gt; circuit.h([qr[0], qr[1]])</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">bit_representation</span><span class="p">[:]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">QuantumCircuit</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">bit_representation</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="nb">int</span><span class="p">):</span>
                <span class="c1"># circuit.h(0) -&gt; circuit.h([qr[0]])</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span><span class="n">in_array</span><span class="p">[</span><span class="n">bit_representation</span><span class="p">]]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bit_representation</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                <span class="c1"># circuit.h(slice(0,2)) -&gt; circuit.h([qr[0], qr[1]])</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">in_array</span><span class="p">[</span><span class="n">bit_representation</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">_is_bit</span><span class="p">(</span><span class="n">bit_representation</span><span class="p">):</span>
                <span class="c1"># circuit.h((qr, 0)) -&gt; circuit.h([qr[0]])</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span><span class="n">bit_representation</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">bit_representation</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bit_representation</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> \
                    <span class="nb">all</span><span class="p">(</span><span class="n">_is_bit</span><span class="p">(</span><span class="n">bit</span><span class="p">)</span> <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="n">bit_representation</span><span class="p">):</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span><span class="n">bit</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">bit</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="n">bit_representation</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bit_representation</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> \
                    <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">bit</span><span class="p">,</span> <span class="n">Bit</span><span class="p">)</span> <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="n">bit_representation</span><span class="p">):</span>
                <span class="c1"># circuit.h([qr[0], qr[1]]) -&gt; circuit.h([qr[0], qr[1]])</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">bit_representation</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">QuantumCircuit</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">bit_representation</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span> <span class="p">(</span><span class="nb">range</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                <span class="c1"># circuit.h([0, 1])     -&gt; circuit.h([qr[0], qr[1]])</span>
                <span class="c1"># circuit.h(range(0,2)) -&gt; circuit.h([qr[0], qr[1]])</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span><span class="n">in_array</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">bit_representation</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s1">&#39;Not able to expand a </span><span class="si">%s</span><span class="s1"> (</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">bit_representation</span><span class="p">,</span>
                                                                    <span class="nb">type</span><span class="p">(</span><span class="n">bit_representation</span><span class="p">)))</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s1">&#39;Index out of range.&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s1">&#39;Type error handling </span><span class="si">%s</span><span class="s1"> (</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">bit_representation</span><span class="p">,</span>
                                                               <span class="nb">type</span><span class="p">(</span><span class="n">bit_representation</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">ret</span>

<div class="viewcode-block" id="QuantumCircuit.qbit_argument_conversion"><a class="viewcode-back" href="../../../api/qiskit.circuit.QuantumCircuit.html#qiskit.circuit.QuantumCircuit.qbit_argument_conversion">[docs]</a>    <span class="k">def</span> <span class="nf">qbit_argument_conversion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qubit_representation</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts several qubit representations (such as indexes, range, etc)</span>
<span class="sd">        into a list of qubits.</span>

<span class="sd">        Args:</span>
<span class="sd">            qubit_representation (Object): representation to expand</span>

<span class="sd">        Returns:</span>
<span class="sd">            List(tuple): Where each tuple is a qubit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">QuantumCircuit</span><span class="o">.</span><span class="n">_bit_argument_conversion</span><span class="p">(</span><span class="n">qubit_representation</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubits</span><span class="p">)</span></div>

<div class="viewcode-block" id="QuantumCircuit.cbit_argument_conversion"><a class="viewcode-back" href="../../../api/qiskit.circuit.QuantumCircuit.html#qiskit.circuit.QuantumCircuit.cbit_argument_conversion">[docs]</a>    <span class="k">def</span> <span class="nf">cbit_argument_conversion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clbit_representation</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts several classical bit representations (such as indexes, range, etc)</span>
<span class="sd">        into a list of classical bits.</span>

<span class="sd">        Args:</span>
<span class="sd">            clbit_representation (Object): representation to expand</span>

<span class="sd">        Returns:</span>
<span class="sd">            List(tuple): Where each tuple is a classical bit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">QuantumCircuit</span><span class="o">.</span><span class="n">_bit_argument_conversion</span><span class="p">(</span><span class="n">clbit_representation</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">clbits</span><span class="p">)</span></div>

<div class="viewcode-block" id="QuantumCircuit.append"><a class="viewcode-back" href="../../../api/qiskit.circuit.QuantumCircuit.html#qiskit.circuit.QuantumCircuit.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instruction</span><span class="p">,</span> <span class="n">qargs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cargs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Append one or more instructions to the end of the circuit, modifying</span>
<span class="sd">        the circuit in place. Expands qargs and cargs.</span>

<span class="sd">        Args:</span>
<span class="sd">            instruction (Instruction or Operation): Instruction instance to append</span>
<span class="sd">            qargs (list(argument)): qubits to attach instruction to</span>
<span class="sd">            cargs (list(argument)): clbits to attach instruction to</span>

<span class="sd">        Returns:</span>
<span class="sd">            Instruction: a handle to the instruction that was just added</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Convert input to instruction</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">instruction</span><span class="p">,</span> <span class="n">Instruction</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">instruction</span><span class="p">,</span> <span class="s1">&#39;to_instruction&#39;</span><span class="p">):</span>
            <span class="n">instruction</span> <span class="o">=</span> <span class="n">instruction</span><span class="o">.</span><span class="n">to_instruction</span><span class="p">()</span>

        <span class="n">expanded_qargs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">qbit_argument_conversion</span><span class="p">(</span><span class="n">qarg</span><span class="p">)</span> <span class="k">for</span> <span class="n">qarg</span> <span class="ow">in</span> <span class="n">qargs</span> <span class="ow">or</span> <span class="p">[]]</span>
        <span class="n">expanded_cargs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cbit_argument_conversion</span><span class="p">(</span><span class="n">carg</span><span class="p">)</span> <span class="k">for</span> <span class="n">carg</span> <span class="ow">in</span> <span class="n">cargs</span> <span class="ow">or</span> <span class="p">[]]</span>

        <span class="n">instructions</span> <span class="o">=</span> <span class="n">InstructionSet</span><span class="p">()</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">qarg</span><span class="p">,</span> <span class="n">carg</span><span class="p">)</span> <span class="ow">in</span> <span class="n">instruction</span><span class="o">.</span><span class="n">broadcast_arguments</span><span class="p">(</span><span class="n">expanded_qargs</span><span class="p">,</span> <span class="n">expanded_cargs</span><span class="p">):</span>
            <span class="n">instructions</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_append</span><span class="p">(</span><span class="n">instruction</span><span class="p">,</span> <span class="n">qarg</span><span class="p">,</span> <span class="n">carg</span><span class="p">),</span> <span class="n">qarg</span><span class="p">,</span> <span class="n">carg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">instructions</span></div>

    <span class="k">def</span> <span class="nf">_append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instruction</span><span class="p">,</span> <span class="n">qargs</span><span class="p">,</span> <span class="n">cargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Append an instruction to the end of the circuit, modifying</span>
<span class="sd">        the circuit in place.</span>

<span class="sd">        Args:</span>
<span class="sd">            instruction (Instruction or Operator): Instruction instance to append</span>
<span class="sd">            qargs (list(tuple)): qubits to attach instruction to</span>
<span class="sd">            cargs (list(tuple)): clbits to attach instruction to</span>

<span class="sd">        Returns:</span>
<span class="sd">            Instruction: a handle to the instruction that was just added</span>

<span class="sd">        Raises:</span>
<span class="sd">            QiskitError: if the gate is of a different shape than the wires</span>
<span class="sd">                it is being attached to.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">instruction</span><span class="p">,</span> <span class="n">Instruction</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s1">&#39;object is not an Instruction.&#39;</span><span class="p">)</span>

        <span class="c1"># do some compatibility checks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_dups</span><span class="p">(</span><span class="n">qargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_qargs</span><span class="p">(</span><span class="n">qargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_cargs</span><span class="p">(</span><span class="n">cargs</span><span class="p">)</span>

        <span class="c1"># add the instruction onto the given wires</span>
        <span class="n">instruction_context</span> <span class="o">=</span> <span class="n">instruction</span><span class="p">,</span> <span class="n">qargs</span><span class="p">,</span> <span class="n">cargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">instruction_context</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_update_parameter_table</span><span class="p">(</span><span class="n">instruction</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">instruction</span>

    <span class="k">def</span> <span class="nf">_update_parameter_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instruction</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">param_index</span><span class="p">,</span> <span class="n">param</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">instruction</span><span class="o">.</span><span class="n">params</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">ParameterExpression</span><span class="p">):</span>
                <span class="n">current_parameters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span>

                <span class="k">for</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="n">param</span><span class="o">.</span><span class="n">parameters</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="n">current_parameters</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_dup_param_spec</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parameter_table</span><span class="p">[</span><span class="n">parameter</span><span class="p">],</span>
                                                          <span class="n">instruction</span><span class="p">,</span> <span class="n">param_index</span><span class="p">):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_table</span><span class="p">[</span><span class="n">parameter</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">instruction</span><span class="p">,</span> <span class="n">param_index</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">parameter</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">{</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">current_parameters</span><span class="p">}:</span>
                            <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span>
                                <span class="s1">&#39;Name conflict on adding parameter: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">parameter</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_table</span><span class="p">[</span><span class="n">parameter</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">instruction</span><span class="p">,</span> <span class="n">param_index</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">instruction</span>

    <span class="k">def</span> <span class="nf">_check_dup_param_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameter_spec_list</span><span class="p">,</span> <span class="n">instruction</span><span class="p">,</span> <span class="n">param_index</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">spec</span> <span class="ow">in</span> <span class="n">parameter_spec_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">spec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">instruction</span> <span class="ow">and</span> <span class="n">spec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">param_index</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="QuantumCircuit.add_register"><a class="viewcode-back" href="../../../api/qiskit.circuit.QuantumCircuit.html#qiskit.circuit.QuantumCircuit.add_register">[docs]</a>    <span class="k">def</span> <span class="nf">add_register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">regs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add registers.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">regs</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">reg</span> <span class="ow">in</span> <span class="n">regs</span><span class="p">]):</span>
            <span class="c1"># QuantumCircuit defined without registers</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">regs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
                <span class="c1"># QuantumCircuit with anonymous quantum wires e.g. QuantumCircuit(2)</span>
                <span class="n">regs</span> <span class="o">=</span> <span class="p">(</span><span class="n">QuantumRegister</span><span class="p">(</span><span class="n">regs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;q&#39;</span><span class="p">),)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">regs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">([</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">reg</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">reg</span> <span class="ow">in</span> <span class="n">regs</span><span class="p">]):</span>
                <span class="c1"># QuantumCircuit with anonymous wires e.g. QuantumCircuit(2, 3)</span>
                <span class="n">regs</span> <span class="o">=</span> <span class="p">(</span><span class="n">QuantumRegister</span><span class="p">(</span><span class="n">regs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;q&#39;</span><span class="p">),</span> <span class="n">ClassicalRegister</span><span class="p">(</span><span class="n">regs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;c&#39;</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s2">&quot;QuantumCircuit parameters can be Registers or Integers.&quot;</span>
                                  <span class="s2">&quot; If Integers, up to 2 arguments. QuantumCircuit was called&quot;</span>
                                  <span class="s2">&quot; with </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">regs</span><span class="p">,))</span>

        <span class="k">for</span> <span class="n">register</span> <span class="ow">in</span> <span class="n">regs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">register</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="n">reg</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">reg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qregs</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">cregs</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s2">&quot;register name </span><span class="se">\&quot;</span><span class="si">%s</span><span class="se">\&quot;</span><span class="s2"> already exists&quot;</span>
                                  <span class="o">%</span> <span class="n">register</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">register</span><span class="p">,</span> <span class="n">QuantumRegister</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qregs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">register</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">register</span><span class="p">,</span> <span class="n">ClassicalRegister</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cregs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">register</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s2">&quot;expected a register&quot;</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_check_dups</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qubits</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raise exception if list of qubits contains duplicates.&quot;&quot;&quot;</span>
        <span class="n">squbits</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">qubits</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">squbits</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">qubits</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s2">&quot;duplicate qubit arguments&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_qargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">qargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raise exception if a qarg is not in this circuit or bad format.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Qubit</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">qargs</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s2">&quot;qarg is not a Qubit&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">has_register</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">register</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">qargs</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s2">&quot;register not in this circuit&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_cargs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raise exception if clbit is not in this circuit or bad format.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">Clbit</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cargs</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s2">&quot;carg is not a Clbit&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">has_register</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">register</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cargs</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s2">&quot;register not in this circuit&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="QuantumCircuit.to_instruction"><a class="viewcode-back" href="../../../api/qiskit.circuit.QuantumCircuit.html#qiskit.circuit.QuantumCircuit.to_instruction">[docs]</a>    <span class="k">def</span> <span class="nf">to_instruction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameter_map</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an Instruction out of this circuit.</span>

<span class="sd">        Args:</span>
<span class="sd">            parameter_map(dict): For parameterized circuits, a mapping from</span>
<span class="sd">               parameters in the circuit to parameters to be used in the</span>
<span class="sd">               instruction. If None, existing circuit parameters will also</span>
<span class="sd">               parameterize the instruction.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Instruction: a composite instruction encapsulating this circuit</span>
<span class="sd">            (can be decomposed back)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">qiskit.converters.circuit_to_instruction</span> <span class="k">import</span> <span class="n">circuit_to_instruction</span>
        <span class="k">return</span> <span class="n">circuit_to_instruction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameter_map</span><span class="p">)</span></div>

<div class="viewcode-block" id="QuantumCircuit.decompose"><a class="viewcode-back" href="../../../api/qiskit.circuit.QuantumCircuit.html#qiskit.circuit.QuantumCircuit.decompose">[docs]</a>    <span class="k">def</span> <span class="nf">decompose</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Call a decomposition pass on this circuit,</span>
<span class="sd">        to decompose one level (shallow decompose).</span>

<span class="sd">        Returns:</span>
<span class="sd">            QuantumCircuit: a circuit one level decomposed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">qiskit.transpiler.passes.decompose</span> <span class="k">import</span> <span class="n">Decompose</span>
        <span class="kn">from</span> <span class="nn">qiskit.converters.circuit_to_dag</span> <span class="k">import</span> <span class="n">circuit_to_dag</span>
        <span class="kn">from</span> <span class="nn">qiskit.converters.dag_to_circuit</span> <span class="k">import</span> <span class="n">dag_to_circuit</span>
        <span class="n">pass_</span> <span class="o">=</span> <span class="n">Decompose</span><span class="p">()</span>
        <span class="n">decomposed_dag</span> <span class="o">=</span> <span class="n">pass_</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">circuit_to_dag</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">dag_to_circuit</span><span class="p">(</span><span class="n">decomposed_dag</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_check_compatible_regs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Raise exception if the circuits are defined on incompatible registers&quot;&quot;&quot;</span>
        <span class="n">list1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qregs</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">cregs</span>
        <span class="n">list2</span> <span class="o">=</span> <span class="n">rhs</span><span class="o">.</span><span class="n">qregs</span> <span class="o">+</span> <span class="n">rhs</span><span class="o">.</span><span class="n">cregs</span>
        <span class="k">for</span> <span class="n">element1</span> <span class="ow">in</span> <span class="n">list1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">element2</span> <span class="ow">in</span> <span class="n">list2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">element2</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">element1</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">element1</span> <span class="o">!=</span> <span class="n">element2</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s2">&quot;circuits are not compatible&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="QuantumCircuit.qasm"><a class="viewcode-back" href="../../../api/qiskit.circuit.QuantumCircuit.html#qiskit.circuit.QuantumCircuit.qasm">[docs]</a>    <span class="k">def</span> <span class="nf">qasm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return OpenQASM string.&quot;&quot;&quot;</span>
        <span class="n">string_temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">header</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">string_temp</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extension_lib</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">for</span> <span class="n">register</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qregs</span><span class="p">:</span>
            <span class="n">string_temp</span> <span class="o">+=</span> <span class="n">register</span><span class="o">.</span><span class="n">qasm</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">for</span> <span class="n">register</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cregs</span><span class="p">:</span>
            <span class="n">string_temp</span> <span class="o">+=</span> <span class="n">register</span><span class="o">.</span><span class="n">qasm</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">for</span> <span class="n">instruction</span><span class="p">,</span> <span class="n">qargs</span><span class="p">,</span> <span class="n">cargs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">instruction</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;measure&#39;</span><span class="p">:</span>
                <span class="n">qubit</span> <span class="o">=</span> <span class="n">qargs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">clbit</span> <span class="o">=</span> <span class="n">cargs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">string_temp</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">[</span><span class="si">%d</span><span class="s2">] -&gt; </span><span class="si">%s</span><span class="s2">[</span><span class="si">%d</span><span class="s2">];</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">instruction</span><span class="o">.</span><span class="n">qasm</span><span class="p">(),</span>
                                                           <span class="n">qubit</span><span class="o">.</span><span class="n">register</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">qubit</span><span class="o">.</span><span class="n">index</span><span class="p">,</span>
                                                           <span class="n">clbit</span><span class="o">.</span><span class="n">register</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">clbit</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">string_temp</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">instruction</span><span class="o">.</span><span class="n">qasm</span><span class="p">(),</span>
                                             <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">[</span><span class="si">%d</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">j</span><span class="o">.</span><span class="n">register</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">j</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
                                                       <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">qargs</span> <span class="o">+</span> <span class="n">cargs</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">string_temp</span></div>

<div class="viewcode-block" id="QuantumCircuit.draw"><a class="viewcode-back" href="../../../api/qiskit.circuit.QuantumCircuit.html#qiskit.circuit.QuantumCircuit.draw">[docs]</a>    <span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">interactive</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">line_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">plot_barriers</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
             <span class="n">reverse_bits</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">justify</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vertical_compression</span><span class="o">=</span><span class="s1">&#39;medium&#39;</span><span class="p">,</span> <span class="n">idle_wires</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
             <span class="n">with_layout</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Draw the quantum circuit</span>

<span class="sd">        **text**: ASCII art TextDrawing that can be printed in the console.</span>

<span class="sd">        **latex**: high-quality images compiled via latex.</span>

<span class="sd">        **latex_source**: raw uncompiled latex output.</span>

<span class="sd">        **matplotlib**: images with color rendered purely in Python.</span>

<span class="sd">        Args:</span>
<span class="sd">            scale (float): scale of image to draw (shrink if &lt; 1)</span>
<span class="sd">            filename (str): file path to save image to</span>
<span class="sd">            style (dict or str): dictionary of style or file name of style</span>
<span class="sd">                file. This option is only used by the ``mpl`` output type. If a</span>
<span class="sd">                str is passed in that is the path to a json file which contains</span>
<span class="sd">                that will be open, parsed, and then used just as the input</span>
<span class="sd">                dict. See: :ref:`Style Dict Doc &lt;style-dict-circ-doc&gt;` for more</span>
<span class="sd">                information on the contents.</span>
<span class="sd">            output (str): Select the output method to use for drawing the</span>
<span class="sd">                circuit. Valid choices are ``text``, ``latex``,</span>
<span class="sd">                ``latex_source``, or ``mpl``. By default the `&#39;text`&#39; drawer is</span>
<span class="sd">                used unless a user config file has an alternative backend set</span>
<span class="sd">                as the default. If the output kwarg is set, that backend</span>
<span class="sd">                will always be used over the default in a user config file.</span>
<span class="sd">            interactive (bool): when set true show the circuit in a new window</span>
<span class="sd">                (for `mpl` this depends on the matplotlib backend being used</span>
<span class="sd">                supporting this). Note when used with either the `text` or the</span>
<span class="sd">                `latex_source` output type this has no effect and will be</span>
<span class="sd">                silently ignored.</span>
<span class="sd">            line_length (int): Deprecated, see `fold` which supersedes this</span>
<span class="sd">                option. Sets the length of the lines generated by `text` output</span>
<span class="sd">                type. This useful when the drawing does not fit in the console.</span>
<span class="sd">                If None (default), it will try to guess the console width using</span>
<span class="sd">                ``shutil.get_terminal_size()``. However, if you&#39;re running in</span>
<span class="sd">                jupyter the default line length is set to 80 characters. If you</span>
<span class="sd">                don&#39;t want pagination at all, set ``line_length=-1``.</span>
<span class="sd">            reverse_bits (bool): When set to True reverse the bit order inside</span>
<span class="sd">                registers for the output visualization.</span>
<span class="sd">            plot_barriers (bool): Enable/disable drawing barriers in the output</span>
<span class="sd">                circuit. Defaults to True.</span>
<span class="sd">            justify (string): Options are ``left``, ``right`` or</span>
<span class="sd">                ``none``, if anything else is supplied it defaults to left</span>
<span class="sd">                justified. It refers to where gates should be placed in the</span>
<span class="sd">                output circuit if there is an option. ``none`` results in</span>
<span class="sd">                each gate being placed in its own column.</span>
<span class="sd">            vertical_compression (string): ``high``, ``medium`` or ``low``. It</span>
<span class="sd">                merges the lines generated by the ``text`` output so the</span>
<span class="sd">                drawing will take less vertical room.  Default is ``medium``.</span>
<span class="sd">                Only used by the ``text`` output, will be silently ignored</span>
<span class="sd">                otherwise.</span>
<span class="sd">            idle_wires (bool): Include idle wires (wires with no circuit</span>
<span class="sd">                elements) in output visualization. Default is True.</span>
<span class="sd">            with_layout (bool): Include layout information, with labels on the</span>
<span class="sd">                physical layout. Default is True.</span>
<span class="sd">            fold (int): Sets pagination. It can be disabled using -1.</span>
<span class="sd">                In `text`, sets the length of the lines. This useful when the</span>
<span class="sd">                drawing does not fit in the console. If None (default), it will</span>
<span class="sd">                try to guess the console width using ``shutil.</span>
<span class="sd">                get_terminal_size()``. However, if running in jupyter, the</span>
<span class="sd">                default line length is set to 80 characters. In ``mpl`` is the</span>
<span class="sd">                number of (visual) layers before folding. Default is 25.</span>
<span class="sd">            ax (matplotlib.axes.Axes): An optional Axes object to be used for</span>
<span class="sd">                the visualization output. If none is specified a new matplotlib</span>
<span class="sd">                Figure will be created and used. Additionally, if specified</span>
<span class="sd">                there will be no returned Figure since it is redundant. This is</span>
<span class="sd">                only used when the ``output`` kwarg is set to use the ``mpl``</span>
<span class="sd">                backend. It will be silently ignored with all other outputs.</span>

<span class="sd">        Returns:</span>
<span class="sd">            :class:`PIL.Image` or :class:`matplotlib.figure` or :class:`str` or</span>
<span class="sd">            :class:`TextDrawing`:</span>

<span class="sd">            * `PIL.Image` (output=&#39;latex&#39;)</span>
<span class="sd">                an in-memory representation of the image of the circuit</span>
<span class="sd">                diagram.</span>
<span class="sd">            * `matplotlib.figure.Figure` (output=&#39;mpl&#39;)</span>
<span class="sd">                a matplotlib figure object for the circuit diagram.</span>
<span class="sd">            * `str` (output=&#39;latex_source&#39;)</span>
<span class="sd">                The LaTeX source code for visualizing the circuit diagram.</span>
<span class="sd">            * `TextDrawing` (output=&#39;text&#39;)</span>
<span class="sd">                A drawing that can be printed as ascii art</span>

<span class="sd">        Raises:</span>
<span class="sd">            VisualizationError: when an invalid output method is selected</span>
<span class="sd">            ImportError: when the output methods requires non-installed</span>
<span class="sd">                libraries.</span>

<span class="sd">        .. _style-dict-circ-doc:</span>

<span class="sd">        **Style Dict Details**</span>

<span class="sd">        The style dict kwarg contains numerous options that define the style of</span>
<span class="sd">        the output circuit visualization. The style dict is only used by the</span>
<span class="sd">        ``mpl`` output. The options available in the style dict are defined</span>
<span class="sd">        below:</span>

<span class="sd">        Args:</span>
<span class="sd">            textcolor (str): The color code to use for text. Defaults to</span>
<span class="sd">                `&#39;#000000&#39;`</span>
<span class="sd">            subtextcolor (str): The color code to use for subtext. Defaults to</span>
<span class="sd">                `&#39;#000000&#39;`</span>
<span class="sd">            linecolor (str): The color code to use for lines. Defaults to</span>
<span class="sd">                `&#39;#000000&#39;`</span>
<span class="sd">            creglinecolor (str): The color code to use for classical register</span>
<span class="sd">                lines. Defaults to `&#39;#778899&#39;`</span>
<span class="sd">            gatetextcolor (str): The color code to use for gate text. Defaults</span>
<span class="sd">                to `&#39;#000000&#39;`</span>
<span class="sd">            gatefacecolor (str): The color code to use for gates. Defaults to</span>
<span class="sd">                `&#39;#ffffff&#39;`</span>
<span class="sd">            barrierfacecolor (str): The color code to use for barriers.</span>
<span class="sd">                Defaults to `&#39;#bdbdbd&#39;`</span>
<span class="sd">            backgroundcolor (str): The color code to use for the background.</span>
<span class="sd">                Defaults to `&#39;#ffffff&#39;`</span>
<span class="sd">            fontsize (int): The font size to use for text. Defaults to 13</span>
<span class="sd">            subfontsize (int): The font size to use for subtext. Defaults to 8</span>
<span class="sd">            displaytext (dict): A dictionary of the text to use for each</span>
<span class="sd">                element type in the output visualization. The default values</span>
<span class="sd">                are::</span>

<span class="sd">                    {</span>
<span class="sd">                        &#39;id&#39;: &#39;id&#39;,</span>
<span class="sd">                        &#39;u0&#39;: &#39;U_0&#39;,</span>
<span class="sd">                        &#39;u1&#39;: &#39;U_1&#39;,</span>
<span class="sd">                        &#39;u2&#39;: &#39;U_2&#39;,</span>
<span class="sd">                        &#39;u3&#39;: &#39;U_3&#39;,</span>
<span class="sd">                        &#39;x&#39;: &#39;X&#39;,</span>
<span class="sd">                        &#39;y&#39;: &#39;Y&#39;,</span>
<span class="sd">                        &#39;z&#39;: &#39;Z&#39;,</span>
<span class="sd">                        &#39;h&#39;: &#39;H&#39;,</span>
<span class="sd">                        &#39;s&#39;: &#39;S&#39;,</span>
<span class="sd">                        &#39;sdg&#39;: &#39;S^\\dagger&#39;,</span>
<span class="sd">                        &#39;t&#39;: &#39;T&#39;,</span>
<span class="sd">                        &#39;tdg&#39;: &#39;T^\\dagger&#39;,</span>
<span class="sd">                        &#39;rx&#39;: &#39;R_x&#39;,</span>
<span class="sd">                        &#39;ry&#39;: &#39;R_y&#39;,</span>
<span class="sd">                        &#39;rz&#39;: &#39;R_z&#39;,</span>
<span class="sd">                        &#39;reset&#39;: &#39;\\left|0\\right\\rangle&#39;</span>
<span class="sd">                    }</span>

<span class="sd">                You must specify all the necessary values if using this. There</span>
<span class="sd">                is no provision for passing an incomplete dict in.</span>
<span class="sd">            displaycolor (dict): The color codes to use for each circuit</span>
<span class="sd">                element. The default values are::</span>

<span class="sd">                    {</span>
<span class="sd">                        &#39;id&#39;: &#39;#F0E442&#39;,</span>
<span class="sd">                        &#39;u0&#39;: &#39;#E7AB3B&#39;,</span>
<span class="sd">                        &#39;u1&#39;: &#39;#E7AB3B&#39;,</span>
<span class="sd">                        &#39;u2&#39;: &#39;#E7AB3B&#39;,</span>
<span class="sd">                        &#39;u3&#39;: &#39;#E7AB3B&#39;,</span>
<span class="sd">                        &#39;x&#39;: &#39;#58C698&#39;,</span>
<span class="sd">                        &#39;y&#39;: &#39;#58C698&#39;,</span>
<span class="sd">                        &#39;z&#39;: &#39;#58C698&#39;,</span>
<span class="sd">                        &#39;h&#39;: &#39;#70B7EB&#39;,</span>
<span class="sd">                        &#39;s&#39;: &#39;#E0722D&#39;,</span>
<span class="sd">                        &#39;sdg&#39;: &#39;#E0722D&#39;,</span>
<span class="sd">                        &#39;t&#39;: &#39;#E0722D&#39;,</span>
<span class="sd">                        &#39;tdg&#39;: &#39;#E0722D&#39;,</span>
<span class="sd">                        &#39;rx&#39;: &#39;#ffffff&#39;,</span>
<span class="sd">                        &#39;ry&#39;: &#39;#ffffff&#39;,</span>
<span class="sd">                        &#39;rz&#39;: &#39;#ffffff&#39;,</span>
<span class="sd">                        &#39;reset&#39;: &#39;#D188B4&#39;,</span>
<span class="sd">                        &#39;target&#39;: &#39;#70B7EB&#39;,</span>
<span class="sd">                        &#39;meas&#39;: &#39;#D188B4&#39;</span>
<span class="sd">                    }</span>

<span class="sd">               Also, just like  `displaytext` there is no provision for an</span>
<span class="sd">               incomplete dict passed in.</span>

<span class="sd">            latexdrawerstyle (bool): When set to True enable latex mode which</span>
<span class="sd">                will draw gates like the `latex` output modes.</span>
<span class="sd">            usepiformat (bool): When set to True use radians for output</span>
<span class="sd">            fold (int): The number of circuit elements to fold the circuit at.</span>
<span class="sd">                Defaults to 20</span>
<span class="sd">            cregbundle (bool): If set True bundle classical registers</span>
<span class="sd">            showindex (bool): If set True draw an index.</span>
<span class="sd">            compress (bool): If set True draw a compressed circuit</span>
<span class="sd">            figwidth (int): The maximum width (in inches) for the output figure.</span>
<span class="sd">            dpi (int): The DPI to use for the output image. Defaults to 150</span>
<span class="sd">            margin (list): A list of margin values to adjust spacing around</span>
<span class="sd">                output image. Takes a list of 4 ints:</span>
<span class="sd">                [x left, x right, y bottom, y top].</span>
<span class="sd">            creglinestyle (str): The style of line to use for classical</span>
<span class="sd">                registers. Choices are `&#39;solid&#39;`, `&#39;doublet&#39;`, or any valid</span>
<span class="sd">                matplotlib `linestyle` kwarg value. Defaults to `doublet`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># pylint: disable=cyclic-import</span>
        <span class="kn">from</span> <span class="nn">qiskit.visualization</span> <span class="k">import</span> <span class="n">circuit_drawer</span>
        <span class="k">return</span> <span class="n">circuit_drawer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span>
                              <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="n">style</span><span class="p">,</span>
                              <span class="n">output</span><span class="o">=</span><span class="n">output</span><span class="p">,</span>
                              <span class="n">interactive</span><span class="o">=</span><span class="n">interactive</span><span class="p">,</span>
                              <span class="n">line_length</span><span class="o">=</span><span class="n">line_length</span><span class="p">,</span>
                              <span class="n">plot_barriers</span><span class="o">=</span><span class="n">plot_barriers</span><span class="p">,</span>
                              <span class="n">reverse_bits</span><span class="o">=</span><span class="n">reverse_bits</span><span class="p">,</span>
                              <span class="n">justify</span><span class="o">=</span><span class="n">justify</span><span class="p">,</span>
                              <span class="n">vertical_compression</span><span class="o">=</span><span class="n">vertical_compression</span><span class="p">,</span>
                              <span class="n">idle_wires</span><span class="o">=</span><span class="n">idle_wires</span><span class="p">,</span>
                              <span class="n">with_layout</span><span class="o">=</span><span class="n">with_layout</span><span class="p">,</span>
                              <span class="n">fold</span><span class="o">=</span><span class="n">fold</span><span class="p">,</span>
                              <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span></div>

<div class="viewcode-block" id="QuantumCircuit.size"><a class="viewcode-back" href="../../../api/qiskit.circuit.QuantumCircuit.html#qiskit.circuit.QuantumCircuit.size">[docs]</a>    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns total number of gate operations in circuit.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: Total number of gate operations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gate_ops</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">instr</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;barrier&#39;</span><span class="p">,</span> <span class="s1">&#39;snapshot&#39;</span><span class="p">]:</span>
                <span class="n">gate_ops</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">gate_ops</span></div>

<div class="viewcode-block" id="QuantumCircuit.depth"><a class="viewcode-back" href="../../../api/qiskit.circuit.QuantumCircuit.html#qiskit.circuit.QuantumCircuit.depth">[docs]</a>    <span class="k">def</span> <span class="nf">depth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return circuit depth (i.e. length of critical path).</span>
<span class="sd">        This does not include compiler or simulator directives</span>
<span class="sd">        such as &#39;barrier&#39; or &#39;snapshot&#39;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: Depth of circuit.</span>

<span class="sd">        Notes:</span>
<span class="sd">            The circuit depth and the DAG depth need not bt the</span>
<span class="sd">            same.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Labels the registers by ints</span>
        <span class="c1"># and then the qubit position in</span>
        <span class="c1"># a register is given by reg_int+qubit_num</span>
        <span class="n">reg_offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">reg_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">reg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qregs</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">cregs</span><span class="p">:</span>
            <span class="n">reg_map</span><span class="p">[</span><span class="n">reg</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">reg_offset</span>
            <span class="n">reg_offset</span> <span class="o">+=</span> <span class="n">reg</span><span class="o">.</span><span class="n">size</span>

        <span class="c1"># A list that holds the height of each qubit</span>
        <span class="c1"># and classical bit.</span>
        <span class="n">op_stack</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">reg_offset</span>
        <span class="c1"># Here we are playing a modified version of</span>
        <span class="c1"># Tetris where we stack gates, but multi-qubit</span>
        <span class="c1"># gates, or measurements have a block for each</span>
        <span class="c1"># qubit or cbit that are connected by a virtual</span>
        <span class="c1"># line so that they all stacked at the same depth.</span>
        <span class="c1"># Conditional gates act on all cbits in the register</span>
        <span class="c1"># they are conditioned on.</span>
        <span class="c1"># We treat barriers or snapshots different as</span>
        <span class="c1"># They are transpiler and simulator directives.</span>
        <span class="c1"># The max stack height is the circuit depth.</span>
        <span class="k">for</span> <span class="n">instr</span><span class="p">,</span> <span class="n">qargs</span><span class="p">,</span> <span class="n">cargs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">:</span>
            <span class="n">levels</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">reg_ints</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># If count then add one to stack heights</span>
            <span class="n">count</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;barrier&#39;</span><span class="p">,</span> <span class="s1">&#39;snapshot&#39;</span><span class="p">]:</span>
                <span class="n">count</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">reg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">qargs</span> <span class="o">+</span> <span class="n">cargs</span><span class="p">):</span>
                <span class="c1"># Add to the stacks of the qubits and</span>
                <span class="c1"># cbits used in the gate.</span>
                <span class="n">reg_ints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reg_map</span><span class="p">[</span><span class="n">reg</span><span class="o">.</span><span class="n">register</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">+</span> <span class="n">reg</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">count</span><span class="p">:</span>
                    <span class="n">levels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op_stack</span><span class="p">[</span><span class="n">reg_ints</span><span class="p">[</span><span class="n">ind</span><span class="p">]]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">levels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op_stack</span><span class="p">[</span><span class="n">reg_ints</span><span class="p">[</span><span class="n">ind</span><span class="p">]])</span>
            <span class="c1"># Assuming here that there is no conditional</span>
            <span class="c1"># snapshots or barriers ever.</span>
            <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">condition</span><span class="p">:</span>
                <span class="c1"># Controls operate over all bits in the</span>
                <span class="c1"># classical register they use.</span>
                <span class="n">cint</span> <span class="o">=</span> <span class="n">reg_map</span><span class="p">[</span><span class="n">instr</span><span class="o">.</span><span class="n">condition</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">off</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">instr</span><span class="o">.</span><span class="n">condition</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">cint</span> <span class="o">+</span> <span class="n">off</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">reg_ints</span><span class="p">:</span>
                        <span class="n">reg_ints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cint</span> <span class="o">+</span> <span class="n">off</span><span class="p">)</span>
                        <span class="n">levels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op_stack</span><span class="p">[</span><span class="n">cint</span> <span class="o">+</span> <span class="n">off</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="n">max_level</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">levels</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">reg_ints</span><span class="p">:</span>
                <span class="n">op_stack</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_level</span>

        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">op_stack</span><span class="p">)</span></div>

<div class="viewcode-block" id="QuantumCircuit.width"><a class="viewcode-back" href="../../../api/qiskit.circuit.QuantumCircuit.html#qiskit.circuit.QuantumCircuit.width">[docs]</a>    <span class="k">def</span> <span class="nf">width</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return number of qubits plus clbits in circuit.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: Width of circuit.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">reg</span><span class="o">.</span><span class="n">size</span> <span class="k">for</span> <span class="n">reg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qregs</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">cregs</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_qubits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return number of qubits.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">qubits</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">reg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qregs</span><span class="p">:</span>
            <span class="n">qubits</span> <span class="o">+=</span> <span class="n">reg</span><span class="o">.</span><span class="n">size</span>
        <span class="k">return</span> <span class="n">qubits</span>

<div class="viewcode-block" id="QuantumCircuit.count_ops"><a class="viewcode-back" href="../../../api/qiskit.circuit.QuantumCircuit.html#qiskit.circuit.QuantumCircuit.count_ops">[docs]</a>    <span class="k">def</span> <span class="nf">count_ops</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Count each operation kind in the circuit.</span>

<span class="sd">        Returns:</span>
<span class="sd">            OrderedDict: a breakdown of how many operations of each kind, sorted by amount.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">count_ops</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">instr</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">count_ops</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">count_ops</span><span class="p">[</span><span class="n">instr</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">count_ops</span><span class="p">[</span><span class="n">instr</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">OrderedDict</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">count_ops</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">kv</span><span class="p">:</span> <span class="n">kv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span></div>

<div class="viewcode-block" id="QuantumCircuit.num_connected_components"><a class="viewcode-back" href="../../../api/qiskit.circuit.QuantumCircuit.html#qiskit.circuit.QuantumCircuit.num_connected_components">[docs]</a>    <span class="k">def</span> <span class="nf">num_connected_components</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unitary_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;How many non-entangled subcircuits can the circuit be factored to.</span>

<span class="sd">        Args:</span>
<span class="sd">            unitary_only (bool): Compute only unitary part of graph.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: Number of connected components in circuit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Convert registers to ints (as done in depth).</span>
        <span class="n">reg_offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">reg_map</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="n">unitary_only</span><span class="p">:</span>
            <span class="n">regs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qregs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">regs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qregs</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">cregs</span>

        <span class="k">for</span> <span class="n">reg</span> <span class="ow">in</span> <span class="n">regs</span><span class="p">:</span>
            <span class="n">reg_map</span><span class="p">[</span><span class="n">reg</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">reg_offset</span>
            <span class="n">reg_offset</span> <span class="o">+=</span> <span class="n">reg</span><span class="o">.</span><span class="n">size</span>
        <span class="c1"># Start with each qubit or cbit being its own subgraph.</span>
        <span class="n">sub_graphs</span> <span class="o">=</span> <span class="p">[[</span><span class="n">bit</span><span class="p">]</span> <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">reg_offset</span><span class="p">)]</span>

        <span class="n">num_sub_graphs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sub_graphs</span><span class="p">)</span>

        <span class="c1"># Here we are traversing the gates and looking to see</span>
        <span class="c1"># which of the sub_graphs the gate joins together.</span>
        <span class="k">for</span> <span class="n">instr</span><span class="p">,</span> <span class="n">qargs</span><span class="p">,</span> <span class="n">cargs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">unitary_only</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="n">qargs</span>
                <span class="n">num_qargs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="n">qargs</span> <span class="o">+</span> <span class="n">cargs</span>
                <span class="n">num_qargs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">condition</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">num_qargs</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">instr</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;barrier&#39;</span><span class="p">,</span> <span class="s1">&#39;snapshot&#39;</span><span class="p">]:</span>
                <span class="n">graphs_touched</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">num_touched</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="c1"># Controls necessarily join all the cbits in the</span>
                <span class="c1"># register that they use.</span>
                <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">condition</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">unitary_only</span><span class="p">:</span>
                    <span class="n">creg</span> <span class="o">=</span> <span class="n">instr</span><span class="o">.</span><span class="n">condition</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">creg_int</span> <span class="o">=</span> <span class="n">reg_map</span><span class="p">[</span><span class="n">creg</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">coff</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">creg</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                        <span class="n">temp_int</span> <span class="o">=</span> <span class="n">creg_int</span> <span class="o">+</span> <span class="n">coff</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_sub_graphs</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">temp_int</span> <span class="ow">in</span> <span class="n">sub_graphs</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                                <span class="n">graphs_touched</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                                <span class="n">num_touched</span> <span class="o">+=</span> <span class="mi">1</span>
                                <span class="k">break</span>

                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
                    <span class="n">reg_int</span> <span class="o">=</span> <span class="n">reg_map</span><span class="p">[</span><span class="n">item</span><span class="o">.</span><span class="n">register</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">+</span> <span class="n">item</span><span class="o">.</span><span class="n">index</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_sub_graphs</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">reg_int</span> <span class="ow">in</span> <span class="n">sub_graphs</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                            <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">graphs_touched</span><span class="p">:</span>
                                <span class="n">graphs_touched</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                                <span class="n">num_touched</span> <span class="o">+=</span> <span class="mi">1</span>
                                <span class="k">break</span>

                <span class="c1"># If the gate touches more than one subgraph</span>
                <span class="c1"># join those graphs together and return</span>
                <span class="c1"># reduced number of subgraphs</span>
                <span class="k">if</span> <span class="n">num_touched</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">connections</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">graphs_touched</span><span class="p">:</span>
                        <span class="n">connections</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sub_graphs</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
                    <span class="n">_sub_graphs</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_sub_graphs</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">graphs_touched</span><span class="p">:</span>
                            <span class="n">_sub_graphs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sub_graphs</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
                    <span class="n">_sub_graphs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">connections</span><span class="p">)</span>
                    <span class="n">sub_graphs</span> <span class="o">=</span> <span class="n">_sub_graphs</span>
                    <span class="n">num_sub_graphs</span> <span class="o">-=</span> <span class="p">(</span><span class="n">num_touched</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Cannot go lower than one so break</span>
            <span class="k">if</span> <span class="n">num_sub_graphs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">num_sub_graphs</span></div>

<div class="viewcode-block" id="QuantumCircuit.num_unitary_factors"><a class="viewcode-back" href="../../../api/qiskit.circuit.QuantumCircuit.html#qiskit.circuit.QuantumCircuit.num_unitary_factors">[docs]</a>    <span class="k">def</span> <span class="nf">num_unitary_factors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes the number of tensor factors in the unitary</span>
<span class="sd">        (quantum) part of the circuit only.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_connected_components</span><span class="p">(</span><span class="n">unitary_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="QuantumCircuit.num_tensor_factors"><a class="viewcode-back" href="../../../api/qiskit.circuit.QuantumCircuit.html#qiskit.circuit.QuantumCircuit.num_tensor_factors">[docs]</a>    <span class="k">def</span> <span class="nf">num_tensor_factors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes the number of tensor factors in the unitary</span>
<span class="sd">        (quantum) part of the circuit only.</span>

<span class="sd">        Notes:</span>
<span class="sd">            This is here for backwards compatibility, and will be</span>
<span class="sd">            removed in a future release of qiskit. You should call</span>
<span class="sd">            `num_unitary_factors` instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_unitary_factors</span><span class="p">()</span></div>

<div class="viewcode-block" id="QuantumCircuit.copy"><a class="viewcode-back" href="../../../api/qiskit.circuit.QuantumCircuit.html#qiskit.circuit.QuantumCircuit.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copy the circuit.</span>

<span class="sd">        Args:</span>
<span class="sd">          name (str): name to be given to the copied circuit, if None then the name stays the same</span>

<span class="sd">        Returns:</span>
<span class="sd">          QuantumCircuit: a deepcopy of the current circuit, with the specified name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cpy</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
            <span class="n">cpy</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">return</span> <span class="n">cpy</span></div>

    <span class="k">def</span> <span class="nf">_create_creg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Creates a creg, checking if ClassicalRegister with same name exists</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="n">creg</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">creg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cregs</span><span class="p">]:</span>
            <span class="n">save_prefix</span> <span class="o">=</span> <span class="n">ClassicalRegister</span><span class="o">.</span><span class="n">prefix</span>
            <span class="n">ClassicalRegister</span><span class="o">.</span><span class="n">prefix</span> <span class="o">=</span> <span class="n">name</span>
            <span class="n">new_creg</span> <span class="o">=</span> <span class="n">ClassicalRegister</span><span class="p">(</span><span class="n">length</span><span class="p">)</span>
            <span class="n">ClassicalRegister</span><span class="o">.</span><span class="n">prefix</span> <span class="o">=</span> <span class="n">save_prefix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_creg</span> <span class="o">=</span> <span class="n">ClassicalRegister</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_creg</span>

<div class="viewcode-block" id="QuantumCircuit.measure_active"><a class="viewcode-back" href="../../../api/qiskit.circuit.QuantumCircuit.html#qiskit.circuit.QuantumCircuit.measure_active">[docs]</a>    <span class="k">def</span> <span class="nf">measure_active</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds measurement to all non-idle qubits. Creates a new ClassicalRegister with</span>
<span class="sd">        a size equal to the number of non-idle qubits being measured.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">qiskit.converters.circuit_to_dag</span> <span class="k">import</span> <span class="n">circuit_to_dag</span>
        <span class="n">dag</span> <span class="o">=</span> <span class="n">circuit_to_dag</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">qubits_to_measure</span> <span class="o">=</span> <span class="p">[</span><span class="n">qubit</span> <span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">qubits</span> <span class="k">if</span> <span class="n">qubit</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dag</span><span class="o">.</span><span class="n">idle_wires</span><span class="p">()]</span>
        <span class="n">new_creg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_creg</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">qubits_to_measure</span><span class="p">),</span> <span class="s1">&#39;measure&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_register</span><span class="p">(</span><span class="n">new_creg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="n">qubits_to_measure</span><span class="p">,</span> <span class="n">new_creg</span><span class="p">)</span></div>

<div class="viewcode-block" id="QuantumCircuit.measure_all"><a class="viewcode-back" href="../../../api/qiskit.circuit.QuantumCircuit.html#qiskit.circuit.QuantumCircuit.measure_all">[docs]</a>    <span class="k">def</span> <span class="nf">measure_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds measurement to all qubits. Creates a new ClassicalRegister with a</span>
<span class="sd">        size equal to the number of qubits being measured.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_creg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_creg</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qubits</span><span class="p">),</span> <span class="s1">&#39;measure&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_register</span><span class="p">(</span><span class="n">new_creg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">barrier</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">measure</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qubits</span><span class="p">,</span> <span class="n">new_creg</span><span class="p">)</span></div>

<div class="viewcode-block" id="QuantumCircuit.remove_final_measurements"><a class="viewcode-back" href="../../../api/qiskit.circuit.QuantumCircuit.html#qiskit.circuit.QuantumCircuit.remove_final_measurements">[docs]</a>    <span class="k">def</span> <span class="nf">remove_final_measurements</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes final measurement on all qubits if they are present.</span>
<span class="sd">        Deletes the ClassicalRegister that was used to store the values from these measurements</span>
<span class="sd">        if it is idle.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=cyclic-import</span>
        <span class="kn">from</span> <span class="nn">qiskit.transpiler.passes</span> <span class="k">import</span> <span class="n">RemoveFinalMeasurements</span>
        <span class="kn">from</span> <span class="nn">qiskit.converters</span> <span class="k">import</span> <span class="n">circuit_to_dag</span>
        <span class="n">dag</span> <span class="o">=</span> <span class="n">circuit_to_dag</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">remove_final_meas</span> <span class="o">=</span> <span class="n">RemoveFinalMeasurements</span><span class="p">()</span>
        <span class="n">new_dag</span> <span class="o">=</span> <span class="n">remove_final_meas</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">dag</span><span class="p">)</span>

        <span class="c1"># Set self&#39;s cregs and instructions to match the new DAGCircuit&#39;s</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cregs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">new_dag</span><span class="o">.</span><span class="n">cregs</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">new_dag</span><span class="o">.</span><span class="n">topological_op_nodes</span><span class="p">():</span>
            <span class="n">qubits</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">qargs</span><span class="p">:</span>
                <span class="n">qubits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_dag</span><span class="o">.</span><span class="n">qregs</span><span class="p">[</span><span class="n">qubit</span><span class="o">.</span><span class="n">register</span><span class="o">.</span><span class="n">name</span><span class="p">][</span><span class="n">qubit</span><span class="o">.</span><span class="n">index</span><span class="p">])</span>

            <span class="n">clbits</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">clbit</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">cargs</span><span class="p">:</span>
                <span class="n">clbits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_dag</span><span class="o">.</span><span class="n">cregs</span><span class="p">[</span><span class="n">clbit</span><span class="o">.</span><span class="n">register</span><span class="o">.</span><span class="n">name</span><span class="p">][</span><span class="n">clbit</span><span class="o">.</span><span class="n">index</span><span class="p">])</span>

            <span class="c1"># Get arguments for classical condition (if any)</span>
            <span class="n">inst</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">inst</span><span class="o">.</span><span class="n">condition</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">condition</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">qubits</span><span class="p">,</span> <span class="n">clbits</span><span class="p">)</span></div>

<div class="viewcode-block" id="QuantumCircuit.from_qasm_file"><a class="viewcode-back" href="../../../api/qiskit.circuit.QuantumCircuit.html#qiskit.circuit.QuantumCircuit.from_qasm_file">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_qasm_file</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Take in a QASM file and generate a QuantumCircuit object.</span>

<span class="sd">        Args:</span>
<span class="sd">          path (str): Path to the file for a QASM program</span>
<span class="sd">        Return:</span>
<span class="sd">          QuantumCircuit: The QuantumCircuit object for the input QASM</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">qasm</span> <span class="o">=</span> <span class="n">Qasm</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="n">path</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_circuit_from_qasm</span><span class="p">(</span><span class="n">qasm</span><span class="p">)</span></div>

<div class="viewcode-block" id="QuantumCircuit.from_qasm_str"><a class="viewcode-back" href="../../../api/qiskit.circuit.QuantumCircuit.html#qiskit.circuit.QuantumCircuit.from_qasm_str">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_qasm_str</span><span class="p">(</span><span class="n">qasm_str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Take in a QASM string and generate a QuantumCircuit object.</span>

<span class="sd">        Args:</span>
<span class="sd">          qasm_str (str): A QASM program string</span>
<span class="sd">        Return:</span>
<span class="sd">          QuantumCircuit: The QuantumCircuit object for the input QASM</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">qasm</span> <span class="o">=</span> <span class="n">Qasm</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">qasm_str</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_circuit_from_qasm</span><span class="p">(</span><span class="n">qasm</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;convenience function to get the parameters defined in the parameter table&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parameter_table</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

<div class="viewcode-block" id="QuantumCircuit.bind_parameters"><a class="viewcode-back" href="../../../api/qiskit.circuit.QuantumCircuit.html#qiskit.circuit.QuantumCircuit.bind_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">bind_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Assign parameters to values yielding a new circuit.</span>

<span class="sd">        Args:</span>
<span class="sd">            value_dict (dict): {parameter: value, ...}</span>

<span class="sd">        Raises:</span>
<span class="sd">            QiskitError: If value_dict contains parameters not present in the circuit</span>

<span class="sd">        Returns:</span>
<span class="sd">            QuantumCircuit: copy of self with assignment substitution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_circuit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">unrolled_value_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unroll_param_dict</span><span class="p">(</span><span class="n">value_dict</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">unrolled_value_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s1">&#39;Cannot bind parameters (</span><span class="si">{}</span><span class="s1">) not present in the circuit.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">value_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">]))</span>

        <span class="k">for</span> <span class="n">parameter</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">unrolled_value_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">new_circuit</span><span class="o">.</span><span class="n">_bind_parameter</span><span class="p">(</span><span class="n">parameter</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="c1"># clear evaluated expressions</span>
        <span class="k">for</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="n">unrolled_value_dict</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">new_circuit</span><span class="o">.</span><span class="n">_parameter_table</span><span class="p">[</span><span class="n">parameter</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">new_circuit</span></div>

    <span class="k">def</span> <span class="nf">_unroll_param_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value_dict</span><span class="p">):</span>
        <span class="n">unrolled_value_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="n">value_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">ParameterExpression</span><span class="p">):</span>
                <span class="n">unrolled_value_dict</span><span class="p">[</span><span class="n">param</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">ParameterVector</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">QiskitError</span><span class="p">(</span><span class="s1">&#39;ParameterVector </span><span class="si">{}</span><span class="s1"> has length </span><span class="si">{}</span><span class="s1">, which &#39;</span>
                                      <span class="s1">&#39;differs from value list </span><span class="si">{}</span><span class="s1"> of &#39;</span>
                                      <span class="s1">&#39;len </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">param</span><span class="p">),</span> <span class="n">value</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)))</span>
                <span class="n">unrolled_value_dict</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">unrolled_value_dict</span>

    <span class="k">def</span> <span class="nf">_bind_parameter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameter</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Assigns a parameter value to matching instructions in-place.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="n">param_index</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_table</span><span class="p">[</span><span class="n">parameter</span><span class="p">]:</span>
            <span class="n">instr</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">param_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">instr</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">param_index</span><span class="p">]</span><span class="o">.</span><span class="n">bind</span><span class="p">({</span><span class="n">parameter</span><span class="p">:</span> <span class="n">value</span><span class="p">})</span>

    <span class="k">def</span> <span class="nf">_substitute_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameter_map</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;For every {existing_parameter: replacement_parameter} pair in</span>
<span class="sd">        parameter_map, substitute replacement for existing in all</span>
<span class="sd">        circuit instructions and the parameter table.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">old_parameter</span><span class="p">,</span> <span class="n">new_parameter</span> <span class="ow">in</span> <span class="n">parameter_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="n">param_index</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_table</span><span class="p">[</span><span class="n">old_parameter</span><span class="p">]:</span>
                <span class="n">new_param</span> <span class="o">=</span> <span class="n">instr</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">param_index</span><span class="p">]</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">old_parameter</span><span class="p">:</span> <span class="n">new_parameter</span><span class="p">})</span>
                <span class="n">instr</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="n">param_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_param</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_table</span><span class="p">[</span><span class="n">new_parameter</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameter_table</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">old_parameter</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_circuit_from_qasm</span><span class="p">(</span><span class="n">qasm</span><span class="p">):</span>
    <span class="c1"># pylint: disable=cyclic-import</span>
    <span class="kn">from</span> <span class="nn">qiskit.converters</span> <span class="k">import</span> <span class="n">ast_to_dag</span>
    <span class="kn">from</span> <span class="nn">qiskit.converters</span> <span class="k">import</span> <span class="n">dag_to_circuit</span>
    <span class="n">ast</span> <span class="o">=</span> <span class="n">qasm</span><span class="o">.</span><span class="n">parse</span><span class="p">()</span>
    <span class="n">dag</span> <span class="o">=</span> <span class="n">ast_to_dag</span><span class="p">(</span><span class="n">ast</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dag_to_circuit</span><span class="p">(</span><span class="n">dag</span><span class="p">)</span>
</pre></div>

        </div>

      <div class="clearer"></div>
    </div><div class="pagenation">
        
        </main>
    </div>
    <script>
        function trackClickEvent (data) {
            if (window.bluemixAnalytics && window.digitalData) {
                var segmentEvent = {
                    productTitle: window.digitalData.page.pageInfo.productTitle,
                    category: window.digitalData.page.pageInfo.analytics.category,
                    url: window.location.href,
                    action: window.location.href + ' - Clicked: ' + data.action,
                    objectType: data.objectType,
                    successFlag: true
                };

                if(data.milestoneName) {
                    segmentEvent = Object.assign(segmentEvent, { milestoneName: data.milestoneName });
                }
                window.bluemixAnalytics.trackEvent('Custom Event', segmentEvent);
            }
        };

        function clickExternalLink() {
            trackClickEvent({
                action: "Tutorials Link in Navbar",
                objectType: "Link",
                milestoneName: "Looked at tutorials"
            });
        };

        var link = document.getElementById('tutorialsLink');
        link.addEventListener('click', clickExternalLink);
    </script>
    <script>
	    var localeRegExp = /\/(locale\/([a-z-]+)\/)?/i;
	    var prefix = '/documentation';
	    function getDefaultLanguage() {
	      return 'en';
	    }
      var el = document.getElementById('language');
      var optionsToSelect = ['en', 'ja']
      function changeLoc(evt) {
        var language = evt.target.options[el.selectedIndex].value;
        var pathname = window.location.pathname.slice(prefix.length);
        if (language === getDefaultLanguage()) {
          window.location.pathname =
            `${prefix}${pathname.replace(localeRegExp, '/')}`;
        } else {
          window.location.pathname =
            `${prefix}${pathname.replace(localeRegExp, `/locale/${language}/`)}`;
        }
      };
      el.addEventListener('change', changeLoc);
      function extractLanguageFromUrl(pathname) {
        const match = pathname.slice(prefix.length).match(localeRegExp);
        return typeof match[2] === 'undefined' ?
                getDefaultLanguage() : match[2];
	    }
      function changeSelect(select) {
        const optionToSelect = extractLanguageFromUrl(window.location.pathname);
        for (var i = 0; i < select.options.length; i++) {
          var o = select.options[i];
          if (optionToSelect == o.value) {
            o.selected = true;
          }
        }
      };
      changeSelect(el);
    </script>
  </body>
</html>